package com.codesungrape.hmcts.BookAPI.service;

import com.codesungrape.hmcts.BookAPI.dto.BookRequest;
import com.codesungrape.hmcts.BookAPI.repository.BookRepository;
import org.springframework.stereotype.Service; // Marks a class as a Service Layer component.
import lombok.RequiredArgsConstructor;

import com.codesungrape.hmcts.BookAPI.entity.Book;

/**
 * Service layer responsible for all business logic related to the Book resource.
 */
@Service
@RequiredArgsConstructor // Lombok creates constructor for dependency injection
public class BookService {

    // Create a field to store the repo
    private final BookRepository bookRepository;

    // 1. CREATE Operation (POST /books)
    public Book createBook(BookRequest request) {
        // Validation check for business rules (e.g., uniqueness, if required)
        if (request == null) {
            throw new NullPointerException("BookRequest cannot be null");
        }


        // REVISIT: Leaving this here for now as i haven't implemented the Controller Layer yet
        // The service layer is duplicating validation that already exists in the
        // BookRequest DTO with @notblank annotations. Since the DTO has validation
        // constraints, this manual check is redundant when Spring's validation
        // framework is properly configured in the controller layer.
        // Consider removing this duplication or adding a comment explaining
        // why service-level validation is necessary in addition to DTO validation.
        if (request.getTitle() == null || request.getTitle().isBlank()) {
            throw new IllegalArgumentException("Book title cannot be null or blank");
        }

        // Map DTO to Entity
        Book newBook = Book.builder()
                .title(request.getTitle())
                .author(request.getAuthor())
                .synopsis(request.getSynopsis())
                // ID and created_at are auto-generated by JPA/DB
                .build();

        Book savedBook = bookRepository.save(newBook);

        // Defensive check (even though it "shouldn't" happen aka follows JPA contract)
        if (savedBook == null) {
            throw new IllegalStateException("Failed to save book - repository returned null");
        }

        return savedBook;
    }
}