package com.codesungrape.hmcts.BookAPI.service;

import com.codesungrape.hmcts.BookAPI.dto.BookRequest;
import com.codesungrape.hmcts.BookAPI.repository.BookRepository;
import org.springframework.stereotype.Service; // Marks a class as a Service Layer component.
import lombok.RequiredArgsConstructor;

import com.codesungrape.hmcts.BookAPI.entity.Book;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Service layer responsible for all business logic related to the Book resource.
 */
@Service
@RequiredArgsConstructor // Lombok creates constructor for dependency injection
public class BookService {

    // Create a field to store the repo
    private final BookRepository bookRepository;

    // 1. CREATE Operation (POST /books)
    public Book createBook(BookRequest request) {
        // Validation check for business rules (e.g., uniqueness, if required) would go here
        if (request == null) {
            throw new NullPointerException("BookRequest cannot be null");
        }

        if (request.getTitle() == null || request.getTitle().isBlank()) {
            throw new IllegalArgumentException("Book title cannot be null or blank");
        }

        // Map DTO to Entity
        Book newBook = Book.builder() //Cannot resolve method 'builder' in 'Book'
                .title(request.getTitle())
                .author(request.getAuthor())
                .synopsis(request.getSynopsis())
                // ID and created_at are auto-generated by JPA/DB
                .build();

        Book savedBook = bookRepository.save(newBook);

        // Defensive check (even though it "shouldn't" happen aka follows JPA contract)
        if (savedBook == null) {
            throw new IllegalStateException("Failed to save book - repository returned null");
        }

        return savedBook;
    }
}